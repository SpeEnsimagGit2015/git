\documentclass[a4paper, 12pt]{article}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[usenames,dvipsnames]{xcolor}


\setcounter{secnumdepth}{4}
% TAILLE DES PAGES (A4 serré)

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}
\setlength{\textwidth}{17cm}
\setlength{\textheight}{24cm}
\setlength{\oddsidemargin}{-.7cm}
\setlength{\evensidemargin}{-.7cm}
\setlength{\topmargin}{-.5in}

% Commandes de mise en page
\newcommand{\textremil}[1]{\emph{\color{red} #1}}
\newcommand{\gitcmd}[1]{\emph{#1}}
\newcommand{\tech}[1]{\emph{#1}}
\newcommand{\fichier}[1]{\emph{#1}}
\newcommand{\nom}[1]{\emph{#1}}
\newcommand{\Fig}[1]{Fig \ref{#1} p. \pageref{#1}}
\newcommand{\itemi}{\item[$\bullet$]}

% differentes contributions
\newenvironment{parremil}{%
  \color{red}
}{%
  \color{white}
}


% Commandes de maths
\newcommand{\fonction}[3]{#1 : #2 \to #3}
\newcommand{\intr}[2]{\left[ #1 ; #2 \right]}
\newcommand{\intn}[2]{\left[\![ #1 ; #2 \right]\!]}
\newcommand{\intro}[2]{\left] #1 ; #2 \right[}
\newcommand{\intrsod}[2]{\left[ #1 ; #2 \right[}
\newcommand{\ps}[2]{\langle #1, #2 \rangle}
\newcommand{\mdelta}[1]{\boldsymbol{\delta_{#1}}}
%% \newcommand{\mdelta}[1]{\delta_{\textbf{#1}}}

\pagenumbering{arabic}
\graphicspath{{images/}}

\title{Rapport du projet de spécialité:\\ Contribution au logiciel libre Git} 
\author{Antoine Delaite \and Louis-Alexandre Stuber \and Guillaume Pagès \and Rémi Galan Alfonso \and Rémi Lespinet}
\date{}

\begin{document}

\maketitle

\section{Introduction}

Le projet de spécialité a été un challenge intéressant. Les quatres semaines ont été intenses, et le groupe a connu une évolution dans l'organisation et la communication durant cette période.\\

Nous avons décidé de contribuer au logiciel libre Git, afin de découvrir l'envers du décor lors du développement d'un logiciel de grande ampleur, mais aussi pour perfectionner notre utilisation de Git, atout précieux en entreprise.

\section{Présentation du logiciel Git}

\subsection{Le logiciel Git}

Git est un logiciel de versionnage très populaire parmi les developpeurs.
Il permet de gérer le travail de plusieurs personnes en parrallèle sur un même projet, ainsi que d'archiver toutes les modifications, pour les réordonner, les éditer ou les supprimmer par la suite.
Git fonctionne grâce à un système de commit, instantané du répertoire courant, qui permet de sauvegarder des ensembles de modifications indépendamment les uns des autres pour pouvoir par la suite les archiver, les retravailler ou les réordonner.

\subsection{Les contraintes de Git}

Git est un logiciel utilisé par des millions de developpeurs (Github, le service web d'hebergement service web d'hébergement et de gestion de développement de logiciels utilisant Git compte 9 millions d'utilisateurs).
Par conséquent, les modifications apportées sur ce logiciel peuvent avoir d'importantes répercutions.
Ainsi, l'une des priorités des contributeurs est de conserver la rétro-compatibilité.
En effet de nombreux projet reposent sur Git, et sont gérés au moins en partie par des scripts automatiques; un défaut de rétro-compatibilité engendrerait donc un gros travail de mise à jour des scripts dans tous ces projets. 
De plus, le code écrit doit être d'une qualité irréprochable afin que les prochains contributeurs soient en mesure de le reprendre facilement.

\section{Nos contributions}

\subsection{git am --3way}

Notre première contribution a été de permettre l'ajout d'une variable de configuration pour une option très courante afin que les utilisateurs ne soient pas obligés de la retaper à chaque fois.

\subsection{git send-email}

Cette contribution a pour but d'autoriser l'utilisation de la commande git send-email en entrant les addresses mails séparées par des virgules (ce qui est le format utilisé par la plupart des client mails). Cette modification permet donc à l'utilisateur de copier-coller une liste d'addresses depuis un mail vers la commande \gitcmd{git send-email} au lieu de devoir taper "--to:" devant chacune des addresses.

\subsection{git rebase --interactive}

La commande \gitcmd{git rebase --interactive} permet d'éditer l'historique des commits, en les déplaçant les uns par rapport aux autres, de les fusionner, de les modifier... à partir d'une liste d'actions qui a été modifiée par l'utilisateur.

Cette contribution a ajouté :
\begin{itemize}
\item la commande \textit{drop}, qui permet d'enlever des commits explicitement au lieu d'enlever ou de commenter la ligne.
\item la variable de configuration \textit{rebase.missingCommitCheck} et un test d'intégrité, ce test vérifie qu'aucun commit n'a disparu. Cette variable de configuration permet de réguler le comportement de ce test d'intégrité. Ce test permet d'éviter des pertes d'informations silencieuses (par exemple on a enlevé une ligne par erreur).
\item des tests d'intégrité statiques, qui permettent de vérifier à l'avance l'intégrité des commandes et des commits de la liste d'actions de l'utilisateur. Ainsi on évite de lever les erreurs à la volée et l'utilisateur peut ainsi corriger ses erreurs avant qu'une seule des actions ne soit effectuée.
\end{itemize}

\subsection{git status}

La commande \gitcmd{git status} affiche l'état du working tree (copie de travail).
Forts de notre expérience sur la commande \gitcmd{git rebase -i}, nous nous sommes lancés dans l'amélioration du message renvoyé par \gitcmd{git status} lorsqu'un rebase (rebasage) interactif est en cours.
Dans un premier temps, nous souhaitions ajouter une option \textit{--status} à la commande \gitcmd{git rebase} afin d'afficher l'état du rebasage en cours. 
Cependant, la communauté était contre l'idée de complexifier le logiciel en rajoutant des options, et un consensus a émergé pour modifier simplement la commande \gitcmd{git status} pour qu'elle ait un comportement dépendant du contexte et que pendant un rebase, elle affiche son état.

\subsection{git bisect}

Il arrive qu'un commit introduise un bug nouveau, qui ne sera découvert que très longtemps après son introduction. \gitcmd{Git bisect} est un groupe de commandes permettant de trouver le premier commit où le bug est apparu. La commande nécessite de préciser au moins une version antérieure où le bug n'existait pas, et procède ensuite par bissection en déplaçant l'utilisateur dans son historique et lui demandant de tester si le bug y est présent.

Jusque là, l'utilisateur devait marquer les commits par des tags "bad" ou "good", tous les commits précédents l'apparition du bug étant "good", et tous les commits ultérieurs étant "bad". Des utilisateurs s'étaient plaints de la rigidité de ces termes, puisque \gitcmd{git bisect} pourrait tout aussi bien être utilisée pour trouver la première fois où un bug a \emph{disparu}, ou même tout simplement le premier commit où un changement a été effectué (indépendamment de tout jugement) et l'utilisateur devait jusque là utiliser "bad" et "good" en faisant comme si ces tags voulaient dire autre chose.

Notre contribution a consisté à rajouter de nouveaux termes : "old" et "new" qui permettent de gérer ces cas. Il s'agissait, contrairement aux apparences, d'une tâche assez complexe, le code source n'ayant pas du tout été prévu pour un tel changement. Nous avons repris le code d'anciens Ensimag qui avaient essayé puis renoncé à implémenter la fonctionnalité. Les termes "old" et "new" ont finalement pu être implémentés, mais le patch n'est pas passé. Nous pensons malgré tout que cette contribution a aidé la communauté, qui débat actuellement de la généralisation de cette fonctionnalité (pour que l'utilisateur puisse choisir les termes) et qui va peut-être reprendre notre code.


\section{La communauté Git}

Le developpement de Git est supervisé par Junio C Hamano, qui s'occupe de synchroniser le travail des autres contributeurs.

L'immense majorité des contributeurs sont des utilisateurs expérimentés de Git, alors que l'une de nos motivation principale dans ce projet était d'améliorer notre maîtrise de Git.

Dès lors, notre point de vue sur le logiciel est très different de celui des autres contributeur, mais pas inintéressant pour autant: nous connaissons mieux les obstacles rencontrées dans l'apprentissage de Git, et donc nous pouvons imaginer des solutions pour les contourner. Cette expérience récente avec Git a par exemple été mise à profit lors des discussions autour de git status lors d'un rebase interactif.

~\\

La communauté Git s'organise autour d'une mailing-list, laquelle reçoit les rapports de bug, les propositions de patchs et les revues de code. Ainsi, tout le monde a accès à toutes les informations, et peut donner son avis, ou proposer des modification.

Ce modèle sans véritable hierarchie est donc très égalitaire, toutefois, il est assez déroutant au début, puisqu'il n'y a pas véritablement de personne qui fasse référence.

Cela impose que les décisions sont prises par consensus et il faut être capable de savoir quand une idée est rejetée, alors que personne ne prend jamais la responsabilité de le dire explicitement.

Ce fonctionnement nous amène donc à prendre en compte les critiques vis à vis de nos contributions, et donc soit d'argumenter pour montrer que celles ci ont un intérêt pour le logiciel soit de se rendre compte que leurs remarques sont fondées et d'accepter de laisser tomber une contribution.

\section{Difficultés}

\subsection{Les difficultés rencontrées}

Les principales difficultés ont été :
\begin{itemize}

\item S'immerger dans la mailing-list : nous avons dû côtoyer d'autres contributeurs de Git qui sont bien plus expérimentés que nous aussi bien au niveau de l'utilisation de Git que des compétences techniques. Ainsi nous avons dû prendre en compte leurs retours, argumenter avec eux quand nous n'étions pas d'accord avec leurs retours.
\item Se plonger dans le code de Git, qui comprend un grand nombre de lignes de code, plusieurs langages (C, Shell, Perl).
\item Apprendre le coding-style demandé, savoir faire un code clair et maintenable.
\item Se plonger dans le code de nos prédécesseurs (élèves en projet de Spécialité des années précédentes sur Git).

\end{itemize}

\subsection{Les solutions}





\section{Enseignements tirés}

\subsection{Enseignements techniques}

Ce premier contact avec le developpement collaboratif de logiciels libres nous a permis de mieux comprendre les enjeux inhérents à des projets de cet ampleur. 
Ce projet nous a permis de travailler avec une importante base de code existante. La lecture du code, de la documentation, et des API a pris bien plus de temps que coder effectivement. Malgré celà, notre manque d'expérience sur ce projet a engendré de nombreuses erreurs de notre part.
C'est sur ce point que l'intégration a une communauté de développeur nous a été très bénéfique, puisque nos erreurs ont été corrigées très régulièrement et nos décisions discutées.
Au contact de ce milieu, nous avons pu appréhender le fossé qui sépare les projets scolaires ou personnels des logiciel réels, en terme de qualité, d'exigence, mais aussi de reflexion autour de chaque décision.

\begin{parremil}
ICI je vais ecrire l'apprentissage de git
\end{parremil}

\begin{parremil}
ICI je vais ecrire l'apprentissage de perl
\end{parremil}

\subsection{Adaptation des méthodes agiles au logiciel Git}

La méthode agile consiste à essayer de réduire la partie gestion de projet au minimum, afin de se concentrer sur l'essentiel du travail du développeur: le code.
Etant donnée le temps imparti pour le projet, nous avons réalisés trois sprints.
Au début de chaque sprint, nous avons défini des objectifs à réaliser, toutefois, notre définition du mot fini a évolué au fur et à mesure du projet afin de s'adapter aux besoins de l'équipe.

Sur certains points, notamment l'adaptation, la méthode agile nous a énormément aidé. En effet, il aurait été impossible de prévoir au début du projet les contributions à réaliser.

D'un autre coté, certaines caractéristiques de ce projet ne se prêtent absolument pas à sa réalisation avec des méthodes agiles:
\begin{itemize}
\item les méthodes agiles mettent le client, et sa collaboration avec les developpeurs au coeur du processus de développement, alors que Git n'a pas de client et la personne chargée de la maintenance du logiciel, la plus à-même de prendre des décisions, vit en décalage horaire avec nous.
\item les méthodes agiles favorisent les logiciels qui fonctionnent plutôt qu'une documentation exhaustive.
Or, les contraintes de l'open-source poussent à être perfectionniste à tout moment du projet, puisque la personne reprenant le code ne sera pas forcément celle qui l'a écrit.
\end{itemize}

Enfin, la méthode scrum introduit des rigidités telles que ne plus avoir de tâches en cours au moment de fin de sprint.
Ces contraintes n'ont pas pu etre respectées étant donné la courte durée des sprints et le temps nécéssaire à l'acceptation d'un patch.
Pour palier ce problème, nous avons fait évoluer notre définition de "fini" au cours du projet: afin de pouvoir finir des stories lors des premiers sprints, nous avons décidé qu'un patch serait fini lorsqu'il est envoyé à la mailing list.
Par la suite, une tâche a été considérée finie lorsqu'elle avait été acceptée par la communauté, et mergée dans la branche proposed updates.
Cette définition n'était pas envisageable lors des premiers sprints, car le temps minimum pour réaliser un patch, le soummettre à la communauté, prendre en compte les retours et finalement obtenir un consensus à son sujet est supérieur à la durée d'un sprint.
Ainsi, lors du dernier sprint, nous n'avons pas commencé de nouvelles fonctionnalité pour nous concentrer sur la finition des fonctionnalités en cours.

\section{Conclusion}

Malgré des débuts hésitants, cette expérience nous a été très bénéfique, en particulier grâce au contact des autres contributeurs plus expérimentés que nous.


\begin{quote} 
   Somehow we are getting quite a many new topics in the past few
weeks.  All the new contributors we acquired recently, including but not limited to the GSoC and Matthieu's students, are making good progress, throwing patches and responding to reviews in a reasonable way, proving themselves to be real assets to the community.
   \begin{flushright}
      Junio C Hamano
   \end{flushright}
\end{quote}



\end{document}
